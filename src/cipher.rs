use crate::polynomial::Polynomial;
use crate::{PublicKey, SecretKey};

use alloc::vec::Vec;

const CONFIG: bincode::config::Configuration<
    bincode::config::LittleEndian,
    bincode::config::Fixint,
    bincode::config::NoLimit,
> = bincode::config::standard()
    .with_little_endian()
    .with_fixed_int_encoding()
    .with_no_limit();

/// Represents a single bit that is encrypted
///
/// You can use this struct to perform operations on encrypted data
#[derive(Debug, Clone)]
pub struct CipheredBit(Polynomial);

impl CipheredBit {
    #[must_use]
    #[inline]
    /// Returns the null bit
    ///
    /// Properties of the system allow you to blindly
    /// use it as if it were a ciphered bit
    pub fn zero() -> Self {
        Self(Polynomial::null())
    }

    #[must_use]
    #[inline]
    /// Returns the bit 1
    ///
    /// Properties of the system allow you to blindly
    /// use it as if it were a ciphered bit
    pub fn one() -> Self {
        Self(Polynomial::monomial(0))
    }

    #[must_use]
    #[inline]
    /// Apply the AND gate to two ciphered bits
    ///
    /// In the backend, this is done by multiplying the two polynomials
    pub fn and(&self, other: &Self) -> Self {
        Self(self.0.mul(&other.0))
    }

    #[must_use]
    #[inline]
    /// Apply the XOR gate to two ciphered bits
    ///
    /// In the backend, this is done by adding the two polynomials
    pub fn xor(&self, other: &Self) -> Self {
        Self(self.0.add(&other.0))
    }

    #[must_use]
    #[inline]
    /// Apply the OR gate to two ciphered bits
    ///
    /// In the backend, this is done by adding the two polynomials and their product
    ///
    /// Keep in mind that it may be faster to simplify the overall expression of your operation
    /// instead of using the OR gate
    pub fn or(&self, other: &Self) -> Self {
        Self(self.0.add(&other.0).add(&self.0.mul(&other.0)))
    }

    #[must_use]
    #[inline]
    /// Apply the NOT gate to a ciphered bit
    ///
    /// In the backend, this is done by adding the polynomial to the unit polynomial
    pub fn not(&self) -> Self {
        self.xor(&Self::one())
    }

    #[must_use]
    // u8 is used instead of bool because they are the same size
    // while u8 can store 8 times more information
    fn part(tau: usize) -> Vec<u8> {
        let num_elements = (tau + 7) / 8;
        let mut part = vec![0; num_elements];

        getrandom::getrandom(&mut part).expect("failed to generate random data");

        part
    }

    #[must_use]
    // See https://github.com/mathisbot/homomorph-rust?tab=readme-ov-file#system
    fn cipher(x: bool, pk: &PublicKey) -> Self {
        let pk = pk.get_polynomials();
        let tau = pk.len();
        let random_part = Self::part(tau);

        let mut sum = Polynomial::new_from_bool(x);
        for i in 0..tau {
            let should_add = random_part[i / 8] & (1 << (i % 8));
            if should_add != 0 {
                sum = sum.add(&pk[i]);
            }
        }

        Self(sum)
    }

    #[must_use]
    // See https://github.com/mathisbot/homomorph-rust?tab=readme-ov-file#system
    fn decipher(&self, sk: &SecretKey) -> bool {
        let remainder = self.0.rem(sk.get_polynomial());
        remainder.evaluate(false)
    }
}

/// This struct is used to create and store encrypted data
#[derive(Debug, Clone)]
pub struct Ciphered<T: crate::Encode + crate::Decode> {
    phantom: core::marker::PhantomData<T>,
    c_data: Vec<CipheredBit>,
}

impl<T: crate::Encode + crate::Decode> Ciphered<T> {
    #[must_use]
    #[inline]
    /// This function is used to create a new `Ciphered` object
    ///
    /// This function should only be used in unsafe contexts
    /// when it is really needed to operate on raw data,
    /// such as when defining homomorphic operations
    ///
    /// ## Safety
    ///
    /// The bits represented by the polynomials must be valid
    /// i.e. generated by the `Ciphered::cipher` function
    /// and processed with extreme care.
    pub const unsafe fn new_from_raw(c_data: Vec<CipheredBit>) -> Self {
        Self {
            phantom: core::marker::PhantomData,
            c_data,
        }
    }

    #[must_use]
    /// Ciphers data
    ///
    /// ## Arguments
    ///
    /// * `data` - The data to encrypt
    /// * `pk` - The public key to use for encryption
    ///
    /// ## Panics
    ///
    /// This function will panic if the serialization of the data fails.
    /// In such cases, you should make sure your struct serializes correctly.
    pub fn cipher(data: &T, pk: &PublicKey) -> Self {
        let bytes = bincode::encode_to_vec(data, CONFIG).expect("Failed to serialize data");

        let mut c_data = Vec::with_capacity(bytes.len() * 8);

        for byte in bytes {
            for i in 0..8 {
                let bit = (byte >> i) & 1;
                c_data.push(CipheredBit::cipher(bit == 1, pk));
            }
        }

        Self {
            phantom: core::marker::PhantomData,
            c_data,
        }
    }

    #[must_use]
    /// Deciphers data
    ///
    /// ## Arguments
    ///
    /// * `self` - The ciphered data to decrypt
    /// * `sk` - The secret key to use for decryption
    ///
    /// ## Panics
    ///
    /// This function will panic if the ciphered data length is not a multiple of 8 or
    /// if the deserialization of the data fails.
    pub fn decipher(&self, sk: &SecretKey) -> T {
        assert_eq!(
            0,
            self.len() % 8,
            "Invalid ciphered data length: expected multiple of 8, got {}",
            self.len()
        );

        let mut bytes = Vec::with_capacity(self.len() / 8);

        let mut byte = 0;
        let mut bit_count: u8 = 0;

        for c_bit in self.iter() {
            let bit = u8::from(c_bit.decipher(sk));
            byte |= bit << bit_count;
            bit_count += 1;

            if bit_count == 8 {
                bytes.push(byte);
                byte = 0;
                bit_count = 0;
            }
        }

        let (d, _) =
            bincode::decode_from_slice(&bytes, CONFIG).expect("Error while deserializing data");

        d
    }
}

impl<T: crate::Encode + crate::Decode> core::ops::Deref for Ciphered<T> {
    type Target = [CipheredBit];

    fn deref(&self) -> &Self::Target {
        &self.c_data
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::{Context, Parameters};
    #[cfg(feature = "derive")]
    use crate::{Decode, Encode};

    #[cfg(feature = "derive")]
    #[derive(Copy, Clone, Debug, PartialEq, Decode, Encode)]
    struct MyStruct {
        a: u32,
        b: u32,
    }

    #[test]
    fn test_cipher() {
        let parameters = Parameters::new(64, 32, 8, 32);
        let mut context = Context::new(parameters);
        context.generate_secret_key();
        context.generate_public_key().unwrap();
        let sk = context.get_secret_key().unwrap();
        let pk = context.get_public_key().unwrap();

        let data = 2_u8;
        let ciphered = Ciphered::cipher(&data, pk);
        assert_eq!(u8::BITS as usize, ciphered.len());
        let decrypted = ciphered.decipher(sk);
        assert_eq!(data, decrypted);

        let data = usize::MAX;
        let ciphered = Ciphered::cipher(&data, pk);
        assert_eq!(usize::BITS as usize, ciphered.len());
        let decrypted = ciphered.decipher(sk);
        assert_eq!(data, decrypted);

        #[cfg(feature = "derive")]
        {
            let data = MyStruct { a: 42, b: 69 };
            let ciphered = Ciphered::cipher(&data, pk);
            assert_eq!(8 * size_of::<MyStruct>(), ciphered.len());
            let decrypted = ciphered.decipher(sk);
            assert_eq!(data, decrypted);
        }
    }

    #[test]
    fn test_deref() {
        let parameters = Parameters::new(64, 32, 8, 32);
        let mut context = Context::new(parameters);
        context.generate_secret_key();
        context.generate_public_key().unwrap();
        let pk = context.get_public_key().unwrap();

        let data = 0b1000_1010_u8;
        let ciphered = Ciphered::cipher(&data, pk);

        // Assert it is possible to work with bits
        let _iter = ciphered.iter();
    }
}
